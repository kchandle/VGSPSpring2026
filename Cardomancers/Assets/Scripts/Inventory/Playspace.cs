using UnityEngine;
using System.Collections.Generic;
using UnityEngine.EventSystems;
using Unity.VisualScripting;

public class Playspace : MonoBehaviour
{
    public PlayItem focusTarget; // the current PlayItem being highlighted
    public float focusOffset = 20f; // how much the focusTarget will be offset from non-focused PlayItem's

    public List<PlayItem> playItems = new List<PlayItem>(); //All PlayItems currently in this PlaySpace

//PlaySpaces that this PlaySpace can accept PlayItems from
// For a PlayItem to move into this playspace, it must be FROM a PlaySpace in this list
    public List<Playspace> allowedDonors = new List<Playspace>(); 

    public bool horizontalLayout = true; // If true, PlayItems will be arranged in a line. If false, a grid



    // Width and padding for the horizontal layout
    // alters how the PlayItems are spaced out


    // wide each spot for a playitem is
    public float width = 10f;

    // how tall each spot for playitem is (only used by GridLayout)
    public float height = 10f;

    // how much space between spots
    public float paddingX = 1f;
    public float paddingY = 1f;

    public float zOffset = .1f; // how much the playItems are offset from the Playspace on the z axis


    public BoxCollider2D playArea; // can be set in the editor if the playArea is not a component of this script's gameObject

    private PlayItem dragTarget; // the currently PlayItem being dragged
    private Vector3 dragTargetPosition; // position of the dragTarget PlayItem
    

    void Awake() 
    {
        if (playArea == null)
        {
           playArea = GetComponent<BoxCollider2D>(); 
        }
        
    
    }

    void Update()
    {
        // Get the focusTarget and dragTargets (if any)
        int targetIndex = playItems.IndexOf(focusTarget);

        switch (horizontalLayout)
        {
            case true: HorizontalLayout(targetIndex); break;
            case false: GridLayout(targetIndex); break;
        }

        if (dragTarget) dragTarget.position = new Vector3 (dragTargetPosition.x, dragTargetPosition.y, dragTarget.position.z);

        focusTarget = null;
        dragTarget = null;
    }

    // Create a new PlayItem in this playspace

    Vector3 defaultPosition = new Vector3(0,0,0);

    // default
    public GameObject NewPlayItem(GameObject prefab)
    {
        GameObject newPlayItem = Instantiate(prefab);
        newPlayItem.transform.SetParent(transform);

        playItems.Add(newPlayItem.GetComponent<PlayItem>());
        return newPlayItem;
    }


        // without position
        public GameObject NewPlayItem(GameObject prefab, Card_SO cardSO){

        print("Spawning this Card: " + cardSO.name);
        GameObject newPlayItem = Instantiate(prefab);
        newPlayItem.transform.SetParent(transform);

 

        playItems.Add(newPlayItem.GetComponent<PlayItem>());

        newPlayItem.GetComponent<Card>().CardSO = cardSO;

        return newPlayItem;
    }


    // Destroys a specific PlayItem in this PlaySpace
    public void DestroyPlayItem(PlayItem playItem)
    {
        if (!playItems.Contains(playItem)) return;
        playItems.Remove(playItem);
        Destroy(playItem.gameObject);
    }

// Arranges all play items in a line
    void HorizontalLayout(int targetIndex = -1)
    {
        int count = playItems.Count;
        float totalWidth = (count * width) + (count - 1) * paddingX;
        Vector3 start = transform.position + Vector3.left * (totalWidth / 2);

        
            for (int i = 0; i < count; i++)
            {
                float index = (float)i + 0.5f;
                Vector3 position = start + Vector3.right * ((index * width) + (i * paddingX));

                if (targetIndex != -1)
                {
                    if (i == targetIndex - 1) position += Vector3.left * focusOffset;
                    else if (i == targetIndex + 1) position += Vector3.right * focusOffset;
                    else if (i == targetIndex) position += Vector3.up * focusOffset;
                }
            position.z += zOffset;
            playItems[i].position = position;
            }

    } 

// Generated by Gemini with human edits
    void GridLayout(int targetIndex = -1, int columns = 2)
    {
        if (playItems == null || playItems.Count == 0 || columns <= 0) 
            return;

        // 1. Calculate how many rows we need
        // We cast to float ensures we get a decimal (e.g., 10/3 = 3.33)
        // CeilToInt rounds 3.33 up to 4.

        int rowCount = Mathf.CeilToInt((float)playItems.Count / columns);
        

        float totalWidth = ((columns - 1) * width) + ((columns - 1) * paddingX);
        float totalHeight = ((rowCount - 1) * height) + (rowCount - 1) * paddingY;


        float startX = transform.position.x - totalWidth / 2.0f;
        float startY = transform.position.y;


        // 2. Loop through the objects to position them
        for (int i = 0; i < playItems.Count; i++)
        {
            // Calculate grid coordinates based on the list index
            int currentRow = i / columns; // Integer division (e.g., 4/3 = 1)
            int currentCol = i % columns; // Modulo operator (e.g., 4%3 = 1)

            // Calculate position
            // We usually multiply 'currentRow' by negative spacing to build downwards
            float xPos = startX + (currentCol * width);
            float yPos = startY - (currentRow * height); 

            if (targetIndex != -1 && i == targetIndex) yPos += focusOffset;


            // Apply position
            if (playItems[i] != null)
            {
                playItems[i].position = new Vector3(xPos, yPos, transform.position.z - (zOffset * i));
            }
        }
    }
    
    // checks if a Vector3 positions it within the PlayArea's bounds
    public bool InPlayArea(Vector3 position)
    {
        return playArea.OverlapPoint(position);
    }

// If the player is hovering over this playspace, get the playItem closest to the player's cursor
// and highlight it
private PlayItem currentTarget = null;
public float selectionBuffer = 0.4f; // Adjust this "stickiness" value as needed

// Function edits generated with Gemini
public PlayItem GetNearestPlayItem(Vector3 position)
{
    if (!InPlayArea(position)) return null;

    PlayItem nearest = null;
    // Use sqrMagnitude for better performance (avoids expensive square root)
    float minSqrDistance = 1000f;

    // 1. Find the absolute closest item
    foreach (PlayItem p in playItems)
    {
        float sqrDistance = (position - p.transform.position).sqrMagnitude;
        if (sqrDistance < minSqrDistance)
        {
            minSqrDistance = sqrDistance;
            nearest = p;
        }
    }

    // Sticky Target: Function favors previously selected target to stop visual jittering
    if (currentTarget != null && nearest != null && currentTarget != nearest)
    {
        float distToCurrent = (position - currentTarget.transform.position).magnitude;
        float distToNew = (position - nearest.transform.position).magnitude;

        // Only switch if the new item is significantly closer than the current one
        if (distToNew < distToCurrent - selectionBuffer)
        {
            currentTarget = nearest;
        }
    }
    else
    {
        currentTarget = nearest;
    }

    return currentTarget;
}

    // Sets the DragTarget. Can be used by other scripts for drag functionality
    public void SetDragTarget(PlayItem dragTarget, Vector3 dragTargetPosition)
    {
        this.dragTarget = dragTarget;
        this.dragTargetPosition = dragTargetPosition;
    }


}
